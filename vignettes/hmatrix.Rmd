---
title: "schnellerGP: H-matrix Functionality"
author: Matthew Wheeler^1^ and Wesley S. Burr^2^
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{schnellerGP: H-matrix Functionality}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

^1^ Biostatistics & Computational Biology Branch, National Institute of Environmental Health Sciences, NIH, Durham, NC, USA

^2^ Department of Mathematics, Trent University, Peterborough, ON, Canada

# Introduction

The schnellerGP package contains two separate interfaces in three threads: 
access to the H2Lib library focused on H matrices; access to the H2lib
library focused on H$^2$ matrices; and access to the Hierarchical Off-Diagonal
Low-Rank (HODLR) library focused on fast linear algebra operations for matrices
formed in that way.

This vignette will explore the function interfaces developed for accessing
and working with H matrices. 

---

# H Matrices

## Description


In numerical analysis, hierarchical matrices (called *H-matrices*) are used as
data-sparse approximations of non-sparse matrices. This allows for representation
of sparse matrices of dimension $n$ in $\mathcal{O}(n)$ units of storage by 
storing only the non-zero entries, while non-sparse matrices would require
$\mathcal{O}(n^2)$ units. Hierarchical matrices provide an approximation to sparse 
matrices requiring only $\mathcal{O}(n k \log(n))$ units of storage, with $k$ being
a parameter controlling the accuracy of the approximation.

The H2Lib library offers a state-of-the-art implementation of **hierarchical**
matrix techniques, and primarily for our interests, data structures for low-rank matrices, H-matrices, and HÂ²-matrices. The library also includes
efficient algorithms for H-matrix arithmetic operations like multiplication, 
inversion, and factorization.

## Basic Functionality

There are only a few implemented wrappers for H-matrices in **schnellerGP**,
with most of the work being focused on H$^2$-matrices and the use of the
HODLR library to manipulate them. In the following code,
a basic R matrix data structure is used to create a matrix of random data.
This data is intended to represent 2D grid locations, and is formed into
a $100 \times 2$ matrix. 

```{r}
A <- matrix(data = rnorm(200),
             nrow = 100,
             ncol = 2)
gp_h2 <- create_h2_kernel(X = as.matrix(A),
                         hp = as.matrix(c(16, 1), ncol = 1),
                         kt = 1)
gp_h  = convert_h2_to_h_matrix(gp = gp_h2)
```

Note that both **gp_h2** and **gp_h** are pointers to memory locations,
but not easily manipulable by the user. 

## Cholesky Decomposition

Matrices already in H-matrix form can then be Cholesky decomposed:

```{r}
cholesky_hmatrix(gp = gp_h)
```

As with **gp_h**, the result is an inline modification of the H-matrix,
resulting in the pointer memory being modified directly.

## Solving Matrix Equations

Given a matrix equation $Ax=b$, with knowledge of $b$
and the $A$ matrix being in H-matrix form, solving the equation can
easily be done:

```{r}
b <- matrix(data = rnorm(100), 
            nrow = 100, 
            ncol = 1)
x <- solve_hmatrix(gp = gp_h, 
                   b = b)
```

Note that this **solve_hmatrix()** function can be called without the 
Cholesky decomposition being applied. If this happens, a full copy is made
of the **A** (H-matrix), the copy is Cholesky decomposed, and then the 
solver runs on the copy. This prevents unintuitive behaviour.

## Log Determinant

A useful operation which we need for some of the work on Gaussian Processes
is to compute the log determinant of a matrix, quickly. 

```{r}
log_sqrt_determinant_hmatrix(gp_h)
```

Note that despite the name, the operation is actually the log-product of the
diagonal:

$$
\sum_{i=1}^{N} \log[\mathbf{diag}(i)] = \log\left[ \prod_{i=1}^{N} \mathbf{diag}(i) \right]
$$

with no square root applied. This is because .... [reason?].

### Read/Write

Finally, wrappers have been written to save and read H-matrices
to disk in NetCDF binary format. For example:

```{r}
save_h_matrix("test.cdf", gp_h)
gp_h_new <- read_h_matrix("test.cdf")
```



















