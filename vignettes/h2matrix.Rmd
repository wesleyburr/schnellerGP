---
title: "schnellerGP: H2 Matrix Integration"
author: Matthew Wheeler^1^ and Wesley S. Burr^2^
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 1
    df_print: kable
    number_sections: true
vignette: >
  %\VignetteIndexEntry{schnellerGP: H2 Matrix Integration}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

^1^ Biostatistics & Computational Biology Branch, National Institute of Environmental Health Sciences, NIH, Durham, NC, USA

^2^ Department of Mathematics, Trent University, Peterborough, ON, Canada

# Introduction

The schnellerGP package contains two separate interfaces in three threads: 
access to the H2Lib library focused on H matrices; access to the H2lib
library focused on H$^2$ matrices; and access to the Hierarchical Off-Diagonal
Low-Rank (HODLR) library focused on fast linear algebra operations for matrices
formed in that way.

This vignette will explore the function interfaces developed for accessing
and working with H$^2$ matrices. 

---

# H$^2$ Matrices

## Description

In numerical analysis, hierarchical matrices (called *H-matrices*) are used as
data-sparse approximations of non-sparse matrices. This allows for representation
of sparse matrices of dimension $n$ in $\mathcal{O}(n)$ units of storage by 
storing only the non-zero entries, while non-sparse matrices would require
$\mathcal{O}(n^2)$ units. Hierarchical matrices provide an approximation to sparse 
matrices requiring only $\mathcal{O}(n k \log(n))$ units of storage, with $k$ being
a parameter controlling the accuracy of the approximation.

In order to scale to even larger problems, the structure of H-matrices has been
improved with the development of H$^2$ matrices. These replace the low-rank structure
of the blocks of an H-matrix with a further hierarchical representation, lowering
the storage complexity to $\mathcal{O}(nk)$. Arithmetic operations like we may
be interested in (e.g., multiplication, inversion, and Cholesky or LR factorization of H$^2$-matrices) can be implemented based on two fundamental operations: the matrix-vector multiplication with submatrices and the low-rank update of submatrices. 

The H2Lib library offers a state-of-the-art implementation of **hierarchical**
matrix techniques, and primarily for our interests, data structures for low-rank matrices, H-matrices, and H$^2$-matrices. 

## Basic Functionality

More wrappers have been implemented for working with $H^2$ matrices in
**schnellerGP**. We can create H$^2$ structured matrices with specific
kernels (our primary interest). The supported kernel types are
restricted to kernel_type


```{r}
library(schnellerGP)
A <- matrix(data = rnorm(200),
             nrow = 100,
             ncol = 2)
gp_h2 <- create_h2_kernel(X = as.matrix(A),
                          hp = as.matrix(c(16, 1), ncol = 1),
                          kt = 1)
```


* start with create_h2_kernel

then solve_h2_vector
solve_h2_vector_start


In the following code,
a basic R matrix data structure is used to create a matrix of random data.
This data is intended to represent 2D grid locations, and is formed into
a $100 \times 2$ matrix. 


Note that both **gp_h2** and **gp_h** are pointers to memory locations,
but not easily manipulable by the user. 

## Cholesky Decomposition

Matrices already in H-matrix form can then be Cholesky decomposed:

```{r}
cholesky_hmatrix(gp = gp_h)
```

As with **gp_h**, the result is an inline modification of the H-matrix,
resulting in the pointer memory being modified directly.

## Solving Matrix Equations

Given a matrix equation $Ax=b$, with knowledge of $b$
and the $A$ matrix being in H-matrix form, solving the equation can
easily be done:

```{r}
b <- matrix(rnorm(100), 100, 1)
x <- solve_hmatrix(gp_h, b)
```

Note that this **solve_hmatrix()** function can be called without the 
Cholesky decomposition being applied. If this happens, a full copy is made
of the **A** (H-matrix), the copy is Cholesky decomposed, and then the 
solver runs on the copy. This prevents unintuitive behaviour.

## Log Determinant

A useful operation which we need for some of the work on Gaussian Processes
is to compute the log determinant of a matrix, quickly. 

```{r}
log_sqrt_determinant_hmatrix(gp_h)
```

Note that despite the name, the operation is actually the log-product of the
diagonal:

$$
\sum_{i=1}^{N} \log[\mathbf{diag}(i)] = \log\left[ \prod_{i=1}^{N} \mathbf{diag}(i) \right]
$$

with no square root applied. This is because .... [reason?].

### Read/Write

Finally, wrappers have been written to save and read H-matrices
to disk in NetCDF binary format. For example:

```{r}
save_h_matrix("test.cdf", gp_h)
gp_h2 <- read_h_matrix("test.cdf")
```



















