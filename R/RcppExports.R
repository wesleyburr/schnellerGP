# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' read_h2_matrix
#'
#' Read an H2-matrix from disk in NetCDF binary format.
#'
#' Read an H2-matrix from disk in NetCDF binary format. Partner function
#' to save_h2_matrix().
#'
#' @param file System file reference or file name.
#' @export
#' @return rv An H2-matrix.
#'
NULL

#' get_h2_idx
#'
#' Given an H2 matrix gp, extract the indexes.
#'
#' @param gp  An H2 matrix.
#' @export
#' @return  The indexes of the input.
#'
NULL

#' create_h2_kernel
#'
#' Return a pointer to a new instance of a h2_lib object.
#'
#' @param X  Matrix of X coordinates to use to form the GP kernel.
#' @param hp Matrix of parameters for the Gaussian Process relative to the
#'             current chosen kernel.
#' @param kt Kernel Type: the type of kernel to use as a number from the list of
#' current supported kernels: gaussian, gaussian_truncate, matern and diagonal.
#' @export
#' @return An H2 matrix with the specified kernel.
#' @examples
#'  # Note the use
#'  A <- matrix(data = rnorm(1000),
#'              nrow = 500,
#'              ncol = 2)
#'  gp_h2 <- create_h2_kernel(X = as.matrix(A),
#'                            hp = as.matrix(c(16, 1), ncol = 1),
#'                            kt = 1)
create_h2_kernel <- function(X, hp, kt) {
    .Call(`_schnellerGP_create_h2_kernel`, X, hp, kt)
}

#' solve_h2_vector
#'
#' Solve Ax=b using H2 matrices.
#'
#' Solve a linear system $Ax=b$ with the preconditioned generalized minimal
#' residual method from H2lib. Note that the underlying H2 class function defaults to
#' iter = 2000 and eps = 1e-14 (eps is overwritten by argument tolerance).
#'
#' @param gp  An H2-matrix
#' @param d_precond   A vector of pre-conditions.
#' @param b  A vector b, for equation $gp*x = b$, with dimension matching that of gp.
#' @export
#' @return
#'  Given inputs gp and b, solves for x in $Ax=b$, and returns it.
#' @examples
#'
#'
#'
solve_h2_vector <- function(gp, d_precond, b, tolerance, iter) {
    .Call(`_schnellerGP_solve_h2_vector`, gp, d_precond, b, tolerance, iter)
}

#' solve_h2_vector_start
#'
#' Solve Ax=b using H2 matrices with initial conditions.
#'
#' Solve a linear system $Ax=b$ with the preconditioned generalized minimal
#' residual method from H2lib, with provided initial condition.
#' Note that the underlying H2 class function defaults to
#' iter = 2000 and eps = 1e-14 (eps is overwritten by argument tolerance).
#'
#' @param gp  An H2-matrix
#' @param d_precond   A vector of pre-conditions.
#' @param b  A vector b, for equation $gp*x = b$, with dimension matching that of gp.
#' @export
#' @return
#'  Given inputs gp and b, solves for x in $Ax=b$, and returns it.
#' @examples
#'
#'
#'
solve_h2_vector_start <- function(gp, d_precond, b, start, tolerance, iter) {
    .Call(`_schnellerGP_solve_h2_vector_start`, gp, d_precond, b, start, tolerance, iter)
}

#' add_diag
#'
#' Add provided vector 'dv' to diagonal of provided H2 matrix gp.
#'
#' @param gp  An H2-matrix.
#' @param dv  A vector to be added to the diagonal.
#' @export
#' @return
#'   Takes gp, and adds dv to the diagonal in place.
#' @examples
#'
add_diag <- function(gp, dv) {
    invisible(.Call(`_schnellerGP_add_diag`, gp, dv))
}

#' multiply_h2_vector
#'
#' Left-multiply provided vector 'dv' by provided H2 matrix gp.
#'
#' @param gp  An H2-matrix.
#' @param dv  A vector to by multiplied by gp, that is, gp * dv.
#' @export
#' @return
#'   Takes gp and dv and computes the multiplication gp * dv.
#' @examples
#'
multiply_h2_vector <- function(gp, dv) {
    .Call(`_schnellerGP_multiply_h2_vector`, gp, dv)
}

#' multiply_h2_stdnorm
#'
#' Multiply an H2 matrix by Standard Normals
#'
#' Given an H2 matrix 'gp', right-multiply it by a vector 'rv' of N(0,1) random numbers.
#'
#' @param gp  An H2-matrix.
#' @export
#' @return
#'   The multiplication gp * rv. Note that the seed in the global environment
#'   is used, as the random normal generation internally to this function
#'   is just rnorm().
#' @examples
#'
multiply_h2_stdnorm <- function(gp) {
    .Call(`_schnellerGP_multiply_h2_stdnorm`, gp)
}

#' convert_h2_to_h_matrix
#'
#' Given an H2 matrix 'gp', convert it to a H matrix.
#'
#' @param gp  An H2-matrix.
#' @export
#' @return
#'   The converted form of the matrix.
#' @examples
#'
convert_h2_to_h_matrix <- function(gp) {
    .Call(`_schnellerGP_convert_h2_to_h_matrix`, gp)
}

#' save_h2_matrix
#'
#' Save an H2-matrix to disk in NetCDF binary format.
#'
#' @param file System file reference or file name.
#' @param gp An H-matrix, likely created by create_h2_kernel or equivalent.
#' @export
#' @return Nothing.
#'
save_h2_matrix <- function(file, gp) {
    invisible(.Call(`_schnellerGP_save_h2_matrix`, file, gp))
}

#' cholesky_hmatrix
#'
#' Convert a matrix into its Cholesky form.
#'
#' @param gp An H-matrix, likely created by create_h2_kernel or equivalent.
#' @return Cholesky decomposition of input.
#' @export
#' @examples
#'  A <- matrix(data = rnorm(1000),
#'              nrow = 500,
#'              ncol = 2)
#'  gp_h2 <- create_h2_kernel(X = as.matrix(A),
#'                            hp = as.matrix(c(16, 1), ncol = 1),
#'                            kt = 1)
#'  gp_h  = convert_h2_to_h_matrix(gp = gp_h2)
#'  cholesky_hmatrix(gp = gp_h)
#'
cholesky_hmatrix <- function(gp) {
    invisible(.Call(`_schnellerGP_cholesky_hmatrix`, gp))
}

#' solve_hmatrix
#'
#' Solve Ax=b, for A an H-matrix
#'
#' Solve a matrix equation Ax=b for x, where A is approximated in H-matrix form.
#'
#' @param gp An H-matrix, likely created by create_h2_kernel() or equivalent.
#' @param b A vector of constants.
#' @return Solution of matrix operation, x.
#' @export
#' @examples
#'  A <- matrix(data = rnorm(1000),
#'              nrow = 500,
#'              ncol = 2)
#'  gp_h2 <- create_h2_kernel(X = as.matrix(A),
#'                            hp = as.matrix(c(16, 1), ncol = 1),
#'                            kt = 1)
#'  gp_h  = convert_h2_to_h_matrix(gp_h2)
#'  cholesky_hmatrix(gp_h)
#'  b <- matrix(rnorm(500), nrow = 500, ncol = 1)
#'  x <- solve_hmatrix(gp_h, b)
#'
solve_hmatrix <- function(gp, x) {
    .Call(`_schnellerGP_solve_hmatrix`, gp, x)
}

#' log_sqrt_determinant_hmatrix
#'
#' Compute the log determinant of an H-matrix
#'
#' Compute the log-determinant of the input H-matrix. Note: no square root
#' is taken at any point in this process, so name is confusing.
#'
#' @param gp An H-matrix, likely created by create_h2_kernel() or equivalent.
#' @export
#' @return Log determinant of the input H-matrix.
#'
log_sqrt_determinant_hmatrix <- function(gp) {
    .Call(`_schnellerGP_log_sqrt_determinant_hmatrix`, gp)
}

#' save_h_matrix
#'
#' Save an H-matrix to disk in NetCDF binary format.
#'
#' @param file System file reference or file name.
#' @param gp An H-matrix, likely created by create_h2_kernel or equivalent.
#' @export
#' @return Nothing.
#'
save_h_matrix <- function(file, gp) {
    invisible(.Call(`_schnellerGP_save_h_matrix`, file, gp))
}

#' read_h_matrix
#'
#' Read an H-matrix from disk in NetCDF binary format.
#'
#' Read an H-matrix from disk in NetCDF binary format. Partner function
#' to save_h_matrix().
#'
#' @param file System file reference or file name.
#' @export
#' @return rv An H-matrix.
#' @examples
#'
#'
#'
read_h_matrix <- function(file) {
    .Call(`_schnellerGP_read_h_matrix`, file)
}

#' multiply_hmat_vec
#'
#' Multiply an H-matrix by a vector.
#'
#' @param h An H-matrix.
#' @param v A vector.
#' @export
#' @return The matrix product of h*v
#'
multiply_hmat_vec <- function(h, v) {
    .Call(`_schnellerGP_multiply_hmat_vec`, h, v)
}

#' get_n_levels
#'
#' Given integers N and M, computes n levels.
#'
#' @param N  Integer.
#' @param M  Integer.
#' @export
#' @return Returns log(N / M) / log(2).
#'
get_n_levels <- function(N, M) {
    .Call(`_schnellerGP_get_n_levels`, N, M)
}

#' setup_compressedMatrixGP_Matern
#'
#' Set Up Compressed Gaussian Process with Matern Kernel
#'
#' Given a matrix of locations X, standard deviation sigma, and length
#' scale rho, sets up a compressed matrix for a Gaussian process using
#' a Matern kernel, with maximum submatrix size M. Default is the case $p=2$.
#'
#' @param X  Matrix of locations.
#' @param sigma  Function standard deviation.
#' @param rho  Length-Scale.
#' @param tol  Tolerance for accuracy of calculations.
#' @param M  Maximum sub-matrix size.
#' @export
#' @return After setting up compressed memory storage, returns a pointer
#'  to a HODLR_Tree object. Specifically, in this case, the Matern kernel
#'  (default) is the case of $p=2$, or $nu = 5/2$.
#'
#'    K(r) = σ^2 * [1 + sqrt(5) * r / ρ + 5/3 * (r / ρ)^2] * exp[-sqrt(5) * r / ρ]
#'
#'  For this implementation, the diagonal elements for the nugget are set to 1e-8.
setup_compressedMatrixGP_Matern <- function(X, sigma, rho, tol, M) {
    .Call(`_schnellerGP_setup_compressedMatrixGP_Matern`, X, sigma, rho, tol, M)
}

#' setup_compressedMatrixGP_MaternP1
#'
#' Set Up Compressed Gaussian Process with Matern (P1) Kernel
#'
#' Given a matrix of locations X, standard deviation sigma, and length
#' scale rho, sets up a compressed matrix for a Gaussian process using
#' a Matern kernel, with maximum submatrix size M. This is the $p=1$ case.
#'
#' @param X  Matrix of locations.
#' @param sigma  Function standard deviation.
#' @param rho  Length-Scale.
#' @param tol  Tolerance for accuracy of calculations.
#' @param M  Maximum sub-matrix size.
#' @export
#' @return After setting up compressed memory storage, returns a pointer
#'  to a HODLR_Tree object. Specifically, in this case, the Matern_p1_Kernel
#'  refers to a kernel with $p=1$ and $nu=3/2$:
#'
#'    K(r) = σ^2 * [1 + sqrt(3) * r / ρ] * exp[-sqrt(3) * r / ρ]
#'
#'  For this implementation, the diagonal elements for the nugget are set to 1.
setup_compressedMatrixGP_MaternP1 <- function(X, sigma, rho, tol, M) {
    .Call(`_schnellerGP_setup_compressedMatrixGP_MaternP1`, X, sigma, rho, tol, M)
}

#' setup_compressedMatrixGP_Matern_tP
#'
#' Set Up Compressed Gaussian Process with Matern (tP) Kernel
#'
#' Given a matrix of locations X, standard deviation sigma, and length
#' scale rho, sets up a compressed matrix for a Gaussian process using
#' a Matern kernel, with maximum submatrix size M. This is $p=2$, with
#' user-provided reciprocal diagonal components for the nugget.
#'
#' @param X  Matrix of locations.
#' @param sigma  Function standard deviation.
#' @param rho  Length-Scale.
#' @param tol  Tolerance for accuracy of calculations.
#' @param M  Maximum sub-matrix size.
#' @export
#' @return After setting up compressed memory storage, returns a pointer
#'  to a HODLR_Tree object. Specifically, in this case, the Matern_pX_Kernel
#'  refers to a kernel such that $p=2$, i.e.,
#'
#'    K(r) = σ^2 * (1 + sqrt(5) * r / ρ + 5/3 * (r / ρ)^2) * exp(-sqrt(5) * r / ρ)
#'
#'  but with the nugget diagonals being set to 1/P, for P a N*1 matrix.
setup_compressedMatrixGP_Matern_tP <- function(X, tP, sigma, rho, tol, M) {
    .Call(`_schnellerGP_setup_compressedMatrixGP_Matern_tP`, X, tP, sigma, rho, tol, M)
}

#' setup_compressedMatrixGP_sqrExp
#'
#' Set Up Compressed Gaussian Process with Square Exponential Kernel
#'
#' Given a matrix of locations X, standard deviation sigma, and length
#' scale rho, sets up a compressed matrix for a Gaussian process using
#' the Squared Exponential kernel.
#'
#' @param X  Matrix of locations.
#' @param sigma  Function standard deviation.
#' @param rho  Length-Scale.
#' @param tol  Tolerance for accuracy of calculations.
#' @param M  Maximum sub-matrix size.
#' @export
#' @returns After setting up compressed memory storage, returns a pointer
#'  to a HODLR_Tree object. Specifically, in this case, kernel is the
#'  Squared Exponential Kernel:
#'
#'    K(r) = σ^2 * exp[ -rho * ||r||^2 ]
#'
#'  with the nugget diagonals set to 1e-8, as with the Matern default.
setup_compressedMatrixGP_sqrExp <- function(X, sigma, rho, tol, M) {
    .Call(`_schnellerGP_setup_compressedMatrixGP_sqrExp`, X, sigma, rho, tol, M)
}

#' setup_compressedMatrixGP_sqrExpP1
#'
#' Set Up Compressed Gaussian Process with Square Exponential (P1) Kernel
#'
#' Given a matrix of locations X, standard deviation sigma, and length
#' scale rho, sets up a compressed matrix for a Gaussian process using
#' the Squared Exponential kernel.
#'
#' @param X  Matrix of locations.
#' @param sigma  Function standard deviation.
#' @param rho  Length-Scale.
#' @param tol  Tolerance for accuracy of calculations.
#' @param M  Maximum sub-matrix size.
#' @export
#' @return After setting up compressed memory storage, returns a pointer
#'  to a HODLR_Tree object. Specifically, in this case, kernel is the
#'  Squared Exponential Kernel:
#'
#'    K(r) = σ^2 * exp[ -rho * ||r||^2 ]
#'
#'  with the nugget diagonals set to 1.0, as with the Matern p1 case.
setup_compressedMatrixGP_sqrExpP1 <- function(X, sigma, rho, tol, M) {
    .Call(`_schnellerGP_setup_compressedMatrixGP_sqrExpP1`, X, sigma, rho, tol, M)
}

#' simulate_compressedMatrixGP
#'
#' Simulate a draw from a compressed GP.
#'
#' @param N Number of observations to draw.
#' @param GPobj  The H matrix, assembled and factorized for use.
#' @export
#' @return  Given N and GPobj, generate N random N(0, 1)s, then
#'    use HODLR code to do a quick symmetric factor product. Returns
#'    the product, which are the draws from the process using compression.
#'
simulate_compressedMatrixGP <- function(N, GPobj) {
    .Call(`_schnellerGP_simulate_compressedMatrixGP`, N, GPobj)
}

#' simulate_compressedMatrixGP_TP
#'
#' Simulate a draw from a compressed Gaussian Process with **something scaled**.
#'
#' @param N Number of observations to draw.
#' @param GPobj  The H matrix, assembled and factorized for use.
#' @param tP  A scale factor (or scale vector??) **
#' @export
#' @return  Given N and GPobj, generate N random N(0, 1)s, scale using tP, then
#'    use HODLR code to do a quick symmetric factor product. Returns
#'    the product, which are the draws from the process using compression.
#'
simulate_compressedMatrixGP_TP <- function(N, GPobj, tP) {
    .Call(`_schnellerGP_simulate_compressedMatrixGP_TP`, N, GPobj, tP)
}

#' getSymmetricFactor
#'
#' Extract symmetric factor from an H matrix
#'
#' Build and return the symmetric factor W from an H matrix, already
#' assembled and factorized.
#'
#' @param GPobj  The H matrix, assembled and factorized for use.
#' @export
#' @return  Extracts the symmetric factor from the Gaussian Process
#' compressed object.
#'
getSymmetricFactor <- function(GPobj) {
    .Call(`_schnellerGP_getSymmetricFactor`, GPobj)
}

#' matmatProduct
#'
#' Compute a matrix-matrix product
#'
#' Compute a matrix-matrix or matrix-vector product of the abstracted
#' kernel matrix and the provided matrix M. Overloads the matmatProduct()
#' function from the Eigen package.
#'
#' @param GPobj  The H matrix, assembled and factorized for use.
#' @param M  A matrix of doubles, as dynamically accessed via Eigen.
#' @export
#' @return  Computes the matrix-matrix product of GPobj and M, which works
#' even if M is a N*1 matrix.
#'
matmatProduct <- function(GPobj, M) {
    .Call(`_schnellerGP_matmatProduct`, GPobj, M)
}

#' solve_HODLR
#'
#' Solve Ax=b using HODLR
#'
#' Solves the matrix equation Ax=b by using the kernel object's abstraction
#' inverse, i.e., A^{-1} * b.
#'
#' @param GPobj  The H matrix, assembled and factorized for use.
#' @param b  A matrix (vector), the right-hand side of the Ax=b equation.
#' @export
#' @return  Solves the matrix equation Ax=b for an A matrix which is already
#' assembled and factorized by HODLR.
#'
solve_HODLR <- function(GPobj, b) {
    .Call(`_schnellerGP_solve_HODLR`, GPobj, b)
}

