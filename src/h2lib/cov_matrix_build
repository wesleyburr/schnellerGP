/* ------------------------------------------------------------
 * Active blocks,
 * i.e., blocks that have to be approximated by the current cluster
 * basis
 * ------------------------------------------------------------ */

typedef struct _compactive compactive;
typedef compactive *pcompactive;

struct _compactive {
  pcamatrix G;			/* Source matrix */
  pcdblock  b;			/* Block */
  uint      iota;		/* Direction */
  amatrix   A;			/* Permuted or compressed submatrix */
  real      weight;		/* Weight factor */
  pcompactive next;		/* Next block in list */
};

/* ------------------------------------------------------------
 * Passive blocks,
 * i.e., blocks that do not have to be approximated by the current
 * cluster basis, but may have to be approximated by its descendants
 * ------------------------------------------------------------ */

typedef struct _comppassive comppassive;
typedef comppassive *pcomppassive;

struct _comppassive {
  pcamatrix G;
  pcdblock  b;
  pcomppassive next;
};

/* ------------------------------------------------------------
 * Destructors
 * ------------------------------------------------------------ */

static void
del_compactive(pcompactive ca)
{
  pcompactive next;

  while (ca) {
    next = ca->next;

    uninit_amatrix(&ca->A);
    freemem(ca);

    ca = next;
  }
}

static void
del_comppassive(pcomppassive cp)
{
  pcomppassive next;

  while (cp) {
    next = cp->next;

    freemem(cp);

    cp = next;
  }
}

/* ------------------------------------------------------------
 * Add a row block to the lists for a given cluster.
 * ------------------------------------------------------------ */

static void
addrow_comp(pcdcluster rc, pcamatrix G, pcdblock b, pctruncmode tm,
	    pcompactive * active, pcomppassive * passive)
{
  pcompactive ca;
  pcomppassive cp;
  pamatrix  Ahat;
  const uint *ridx, *cidx;
  size_t    ldA, ldG;
  uint      rsize, csize;
  real      norm, weight;
  uint      rsons, csons;
  uint      i, j;

  if (b->son) {
    rsons = b->rsons;
    csons = b->csons;

    /* Check whether there is a son matching the cluster rc */
    i = 0;
    while (i < rsons && b->son[i]->rc != rc)
      i++;

    /* If there is, check the sons recursively */
    if (i < rsons) {
      for (j = 0; j < csons; j++)
	addrow_comp(rc, G, b->son[i + j * rsons], tm, active, passive);
    }
    else {			/* Otherwise, this matrix block is passive */
      assert(b->rc == rc);

      cp = (pcomppassive) allocmem(sizeof(comppassive));
      cp->G = G;
      cp->b = b;
      cp->next = *passive;
      *passive = cp;
    }
  }
  else if (b->adm) {
    assert(b->rc == rc);

    /* Create an active block */
    rsize = b->rc->size;
    csize = b->cc->size;
    ca = (pcompactive) allocmem(sizeof(compactive));
    ca->G = G;
    ca->b = b;
    ca->iota = b->rd;
    Ahat = init_amatrix(&ca->A, rsize, csize);
    ca->next = *active;
    *active = ca;

    /* Copy entries from original matrix G */
    ldG = G->ld;
    ldA = Ahat->ld;
    ridx = b->rc->idx;
    cidx = b->cc->idx;
    for (j = 0; j < csize; j++)
      for (i = 0; i < rsize; i++)
          Ahat->a[i + j * ldA] = G->a[ridx[i] + cidx[j] * ldG];

    /* Compute weight factor if necessary */
    weight = 1.0;
    if (tm && tm->blocks) {
      norm = (tm->frobenius ? normfrob_amatrix(Ahat) : norm2_amatrix(Ahat));
      if (norm > 0.0)
	weight = 1.0 / norm;
    }
    ca->weight = weight;
  }
}
